---
alwaysApply: true
---


# OPNsense Config Faker - AI Coding Assistant Rules

The primary function of this project is to generate OPNsense firewall configuration in XML format using randomly generated, but valid, data. These configurations are used to test various security tools and services that parse and validate OPNsense XML configurations.

This document outlines the coding standards, architectural patterns, and project layout preferences for the OPNsense Config Faker project. It serves as a comprehensive guide for AI coding assistants to ensure consistency, maintainability, and adherence to established best practices.

## Core Philosophy

**Framework-First Principle**: Always prefer built-in functionality from frameworks like Clap and Serde over custom or "clever" solutions. Trust the framework's serialization, validation, and CLI mechanisms.

**Operator-Centric Design**: Projects are built for operators, by operators. This means prioritizing workflows that are efficient, auditable, and functional in contested or airgapped environments.

**Single Platform Focus**: OPNsense firewall configuration generation only - not a general network configuration tool. This functionality may come in the future, but is not the primary focus of this project at this time. Plan for the future accordingly, but build for the present.

## Project Structure and Layout

The project follows a structured layout with clear separation of concerns:

```text
/
├── src/
│   ├── cli/               # Command line interface (Clap)
│   ├── generator/         # Core data generation logic
│   ├── io/               # Input/output handling (CSV, XML)
│   ├── model/            # Data models and structures
│   ├── validate/         # Validation framework
│   ├── xml/              # XML processing and generation
│   └── lib.rs            # Library entry point
├── tests/                # Integration tests
├── benches/              # Performance benchmarks
├── justfile              # Task runner configuration
└── Cargo.toml            # Project metadata and dependencies
```

## Technology Stack

The preferred technology stack is consistent across the project:

| Layer        | Technology                                    | Notes                                             |
| ------------ | -------------------------------------------- | ------------------------------------------------- |
| **Language** | Rust 2021 Edition                           | Modern Rust with idiomatic patterns.             |
| **CLI**      | Clap v4 with derive macros                  | For clean, user-friendly command-line interfaces. |
| **Serialization** | serde with CSV/XML support              | For data interchange and file I/O.               |
| **XML**      | quick-xml or roxmltree                      | For OPNsense XML configuration handling.         |
| **Testing**  | built-in test framework, criterion.rs       | For unit tests and performance benchmarking.     |
| **CI/CD**    | GitHub Actions                              | For automated testing, linting, and releases.    |
| **Tooling**  | `cargo` for deps, `just` for task running   | `cargo clippy` and `cargo fmt` for quality.      |

## Architecture Patterns

- **Command Pattern**: CLI commands encapsulated as discrete operations
- **Builder Pattern**: Used for complex configuration objects
- **Strategy Pattern**: Pluggable algorithms for different output formats
- **Error Chaining**: Comprehensive error context through the call stack
- **Resource Management**: RAII principles for file handles and system resources

## Coding Standards and Conventions

### Rust

- **Formatting**: `cargo fmt` using standard Rust formatting.
- **Linting**: `cargo clippy -- -D warnings` to enforce strict zero-warning policy.
- **Naming**: Follow standard Rust conventions - `snake_case` for variables/functions, `PascalCase` for types.
- **Error Handling**: Use `Result<T, E>` types and `?` operator. Create custom error types when needed.
- **Documentation**: Comprehensive `///` doc comments for all public APIs.
- **Testing**: Unit tests co-located with code, integration tests in `tests/` directory.

### Go-Style Organization Principles

Following idiomatic Rust standards:

- **Package Structure**: Clear module hierarchy with single responsibility
- **Naming**: Descriptive names that convey intent and scope
- **Error Handling**: Explicit error handling with context preservation
- **Testing**: Table-driven tests where applicable, comprehensive coverage
- **Documentation**: Self-documenting code with clear examples

### Commit Messages

- **Conventional Commits**: All commit messages must adhere to the [Conventional Commits](https://www.conventionalcommits.org) specification.
  - **Types**: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`
  - **Scopes**: `(cli)`, `(generator)`, `(xml)`, `(validation)`, `(io)`, etc.
  - **Breaking Changes**: Indicated with `!` in the header or `BREAKING CHANGE:` in the footer

## Quality Assurance

### Development Rules of Engagement

- **Clippy Strict**: Always enforce `cargo clippy -- -D warnings` - zero tolerance for warnings
- **OpenAPI Generator**: Use OpenAPI Generator for client code generation where applicable
- **TERM=dumb Support**: Ensure terminal output respects `TERM="dumb"` for CI environments
- **CodeRabbit.ai Preferred**: Use coderabbit.ai for code review over GitHub Copilot auto-reviews
- **Single Maintainer**: Configure workflows for single maintainer (UncleSp1d3r) without second reviewer
- **No Auto-commits**: Never commit code automatically without explicit maintainer permission
- **Pre-Commit CI Check**: **MANDATORY** - Always run `just ci-check` before committing any work to ensure all quality gates pass

### Testing Strategy

A comprehensive testing approach:

1. **Unit Tests**: Co-located with modules using `#[cfg(test)]`
2. **Integration Tests**: End-to-end workflows in `tests/` directory
3. **Benchmarks**: Performance regression detection in `benches/` directory
4. **Property Tests**: Using `proptest` for edge case discovery
5. **CI Validation**: All tests must pass in CI with strict linting

## Common Commands and Workflows

### Development Commands

- `cargo build` - Build the project
- `cargo test` - Run all tests
- `cargo bench` - Run benchmarks
- `just qa` - Run quality assurance checks
- `just clippy` - Run strict clippy lints

### Quality Assurance

- `cargo clippy -- -D warnings` - Strict linting (zero warnings)
- `cargo fmt --check` - Check code formatting
- `cargo audit` - Security vulnerability scan
- `cargo doc` - Generate documentation

### Testing

- `cargo test --lib` - Run unit tests
- `cargo test --test integration_tests` - Run integration tests
- `TERM=dumb cargo test` - Test with dumb terminal

## EvilBit Labs Standards Integration

### Brand Principles

- **Trust the Operator**: Full control, no black boxes
- **Polish Over Scale**: Quality over feature-bloat
- **Offline First**: Built for where the internet isn't
- **Sane Defaults**: Clean outputs, CLI help that's actually helpful
- **Ethical Constraints**: No dark patterns, spyware, or telemetry

### Security and Quality Requirements

- **No hardcoded secrets**: Use environment variables or secure vaults
- **Input validation**: Validate all inputs before processing
- **Offline-first**: No external dependencies or telemetry in production artifacts
- **Cross-platform**: Support macOS, Windows, and Linux
- **Airgap-ready**: All functionality must work offline

### CI/CD Integration

- **Conventional Commits**: All commit messages must follow specification
  - Types: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`
  - Scopes: `(cli)`, `(generator)`, `(xml)`, `(validation)`, `(io)`, etc.
  - Breaking Changes: Indicated with `!` in the header or `BREAKING CHANGE:` in the footer
- **Branch Protection**: Strict linting, testing, and security gates
- **Release Automation**: Release Please manages versioning and changelog

## AI Assistant Behavior and Rules of Engagement

### Core Development Rules

- **Clippy Strict Enforcement**: Always use `cargo clippy -- -D warnings` to enforce zero-warning policy
- **OpenAPI Generator**: Use OpenAPI Generator for Rust client code generation where applicable
- **TERM=dumb Support**: Ensure terminal output respects `TERM="dumb"` environment variable for CI/automation
- **CodeRabbit.ai Integration**: Prefer coderabbit.ai for code review over GitHub Copilot auto-reviews
- **Single Maintainer Workflow**: Configure for single maintainer (UncleSp1d3r) with no second reviewer requirement
- **No Auto-commits**: Never commit code on behalf of maintainer without explicit permission

### Assistant Guidelines

- **Clarity and Precision**: Be direct, professional, and context-aware in all interactions
- **Adherence to Standards**: Strictly follow the defined rules for code style and project structure
- **Tool Usage**: Use `cargo` for Rust development, `just` for task execution
- **Respect Legacy**: Don't modify legacy Python code unless specifically requested
- **Focus on Value**: Enhance the project's unique value proposition as a network configuration data generator
- **Ethical Boundaries**: Always respect the original project authors and encourage upstream usage where appropriate

### Code Generation Requirements

- Generated code must conform to all established patterns
- Include comprehensive type safety through Rust's type system
- Use proper error handling with context preservation
- Follow architectural patterns (Command, Builder, Strategy)
- Include appropriate documentation and testing

## Rust Implementation Features

### Architecture Patterns

- **Command Pattern**: CLI commands encapsulated as discrete operations
- **Builder Pattern**: Used for complex configuration objects
- **Strategy Pattern**: Pluggable algorithms for different output formats
- **Error Chaining**: Comprehensive error context through the call stack
- **Resource Management**: RAII principles for file handles and system resources

### Performance Considerations

- **Memory Safety**: Leverage Rust's ownership system for safe memory management
- **Zero-Cost Abstractions**: Use Rust's zero-cost abstractions for performance
- **Benchmarking**: Use criterion.rs for performance regression detection
- **Streaming I/O**: Efficient processing of large configuration sets

### Usage Examples

```bash
# Primary use case - Generate OPNsense XML configuration
cargo run -- xml --base-config config.xml --count 25

# Generate CSV for intermediate processing (rarely needed directly)
cargo run -- csv --count 25

# Use existing CSV file for XML generation (advanced usage)
cargo run -- xml --base-config config.xml --csv-file my-data.csv

# Run benchmarks
cargo bench

# Run quality checks
just qa
```

## Project-Specific Notes

### OPNsense Config Faker

- Primary focus on OPNsense firewall configuration generation
- CSV is an intermediate format, XML is the primary output
- Realistic network data generation with RFC compliance
- Support for both CLI usage and programmatic integration
- **Legacy Implementation**: Python code preserved in `legacy/` directory for reference only
- **Current Implementation**: Rust-based with modern patterns and performance

### Critical Code Management

- **⚠️ CRITICAL**: Never manually edit files in `opnsense/models/` - they are generated from XSD
- Use `just generate-models` or xsdata commands to regenerate models when schema changes
- Generated model files should be committed to version control but never manually modified
- If customization is needed, extend generated models in separate files, don't modify originals
- **Rust Models**: Use hand-written Rust models in `src/model/` for new implementation
- **Legacy Respect**: Preserve attribution to original nett-media/opnsense-config-generator work. Any use of the XML files in the `legacy/` directory should explicity credit the original work of nett-media and refer users to the original project for OPNsense-specific needs.

### Data Generation Principles

- **Realistic Data**: Generate RFC-compliant network configurations
- **Unique Values**: Ensure no duplicate VLAN IDs or conflicting IP ranges
- **Configurable**: Allow users to specify count, output format, and other parameters
- **Consistent**: Maintain consistent data patterns across generated records

### Performance and Security

- Memory-efficient processing for large configuration sets
- Streaming I/O for handling large datasets
- Benchmark-driven optimization with regression detection
- Cross-platform compatibility (Windows, macOS, Linux)
- **No telemetry**: No external network calls or data collection
- **Offline operation**: Full functionality without internet connectivity
- **Input validation**: Comprehensive validation of all inputs
- **Memory safety**: Rust's memory safety guarantees prevent common vulnerabilities

## Deployment and Release Management

- Deployments should not include generated test data
- Production versions must be tested thoroughly before release
- Use Release Please for automated versioning and changelog generation
- All releases must pass comprehensive quality gates (linting, testing, security)
- Cross-platform compatibility must be verified before release

## Contributions and Community

- Contributions should adhere to existing code style and practices
- All contributors must sign a Contributor License Agreement (CLA)
- Feature requests are encouraged but should align with project goals
- Code reviews are required for all pull requests
- Single maintainer workflow (UncleSp1d3r) with no second reviewer requirement

## Future Roadmap Considerations

- Comprehensive test suite with property-based testing using proptest
- Enhanced OPNsense configuration elements (additional modules, more realistic data)
- Configuration validation and consistency checking for OPNsense configs
- Enhanced XML template system for different OPNsense versions
- Improved realistic data generation for OPNsense-specific features
- Performance optimization through benchmarking and profiling

**Note**: Supporting other platforms or output formats beyond OPNsense XML is explicitly NOT a feature goal

## Key Reminders

1. **Single Platform Focus**: This tool is exclusively for OPNsense firewall configurations
2. **Rust Implementation**: Core functionality is being migrated from Python to Rust
3. **Legacy Respect**: Preserve attribution to original work and don't modify generated legacy code
4. **Quality First**: Zero warnings policy, comprehensive testing, performance benchmarking
5. **Operator-Centric**: Build for network operators who need reliable, offline-capable tools
6. **Ethical Development**: Respect upstream project and maintain proper boundaries
