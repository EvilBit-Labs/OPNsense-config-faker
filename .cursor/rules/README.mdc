---
alwaysApply: true
---


# OPNsense Config Faker - AI Coding Assistant Rules

The primary function of this project is to generate OPNsense firewall configuration in XML format using randomly generated, but valid, data. These configurations are used to test various security tools and services that parse and validate OPNsense XML configurations.

This document outlines the coding standards, architectural patterns, and project layout preferences for the OPNsense Config Faker project. It serves as a comprehensive guide for AI coding assistants to ensure consistency, maintainability, and adherence to established best practices.

## Core Philosophy

**Framework-First Principle**: Always prefer built-in functionality from frameworks like Clap and Serde over custom or "clever" solutions. Trust the framework's serialization, validation, and CLI mechanisms.

**Operator-Centric Design**: Projects are built for operators, by operators. This means prioritizing workflows that are efficient, auditable, and functional in contested or airgapped environments.

**Single Platform Focus**: OPNsense firewall configuration generation only - not a general network configuration tool. This functionality may come in the future, but is not the primary focus of this project at this time. Plan for the future accordingly, but build for the present.

## Project Structure and Layout

The project follows a structured layout with clear separation of concerns:

```text
/
├── src/
│   ├── cli/               # Command line interface (Clap)
│   ├── generator/         # Core data generation logic
│   ├── io/               # Input/output handling (CSV, XML)
│   ├── model/            # Data models and structures
│   ├── validate/         # Validation framework
│   ├── xml/              # XML processing and generation
│   └── lib.rs            # Library entry point
├── tests/                # Integration tests
├── benches/              # Performance benchmarks
├── justfile              # Task runner configuration
└── Cargo.toml            # Project metadata and dependencies
```

## Technology Stack

The preferred technology stack is consistent across the project:

| Layer        | Technology                                    | Notes                                             |
| ------------ | -------------------------------------------- | ------------------------------------------------- |
| **Language** | Rust 2021 Edition                           | Modern Rust with idiomatic patterns.             |
| **CLI**      | Clap v4 with derive macros                  | For clean, user-friendly command-line interfaces. |
| **Serialization** | serde with CSV/XML support              | For data interchange and file I/O.               |
| **XML**      | quick-xml or roxmltree                      | For OPNsense XML configuration handling.         |
| **Testing**  | built-in test framework, criterion.rs       | For unit tests and performance benchmarking.     |
| **CI/CD**    | GitHub Actions                              | For automated testing, linting, and releases.    |
| **Tooling**  | `cargo` for deps, `just` for task running   | `cargo clippy` and `cargo fmt` for quality.      |

## Architecture Patterns

- **Command Pattern**: CLI commands encapsulated as discrete operations
- **Builder Pattern**: Used for complex configuration objects
- **Strategy Pattern**: Pluggable algorithms for different output formats
- **Error Chaining**: Comprehensive error context through the call stack
- **Resource Management**: RAII principles for file handles and system resources

## Coding Standards and Conventions

### Rust

- **Formatting**: `cargo fmt` using standard Rust formatting.
- **Linting**: `cargo clippy -- -D warnings` to enforce strict zero-warning policy.
- **Naming**: Follow standard Rust conventions - `snake_case` for variables/functions, `PascalCase` for types.
- **Error Handling**: Use `Result<T, E>` types and `?` operator. Create custom error types when needed.
- **Documentation**: Comprehensive `///` doc comments for all public APIs.
- **Testing**: Unit tests co-located with code, integration tests in `tests/` directory.

### Go-Style Organization Principles

Following idiomatic Rust standards:

- **Package Structure**: Clear module hierarchy with single responsibility
- **Naming**: Descriptive names that convey intent and scope
- **Error Handling**: Explicit error handling with context preservation
- **Testing**: Table-driven tests where applicable, comprehensive coverage
- **Documentation**: Self-documenting code with clear examples

### Commit Messages

- **Conventional Commits**: All commit messages must adhere to the [Conventional Commits](https://www.conventionalcommits.org) specification.
  - **Types**: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`
  - **Scopes**: `(cli)`, `(generator)`, `(xml)`, `(validation)`, `(io)`, etc.
  - **Breaking Changes**: Indicated with `!` in the header or `BREAKING CHANGE:` in the footer

## Quality Assurance

### Development Rules of Engagement

- **Clippy Strict**: Always enforce `cargo clippy -- -D warnings` - zero tolerance for warnings
- **OpenAPI Generator**: Use OpenAPI Generator for client code generation where applicable
- **TERM=dumb Support**: Ensure terminal output respects `TERM="dumb"` for CI environments
- **CodeRabbit.ai Preferred**: Use coderabbit.ai for code review over GitHub Copilot auto-reviews
- **Single Maintainer**: Configure workflows for single maintainer (UncleSp1d3r) without second reviewer
- **No Auto-commits**: Never commit code automatically without explicit maintainer permission

### Testing Strategy

A comprehensive testing approach:

1. **Unit Tests**: Co-located with modules using `#[cfg(test)]`
2. **Integration Tests**: End-to-end workflows in `tests/` directory
3. **Benchmarks**: Performance regression detection in `benches/` directory
4. **Property Tests**: Using `proptest` for edge case discovery
5. **CI Validation**: All tests must pass in CI with strict linting

## Common Commands and Workflows

### Development Commands

- `cargo build` - Build the project
- `cargo test` - Run all tests
- `cargo bench` - Run benchmarks
- `just qa` - Run quality assurance checks
- `just clippy` - Run strict clippy lints

### Quality Assurance

- `cargo clippy -- -D warnings` - Strict linting (zero warnings)
- `cargo fmt --check` - Check code formatting
- `cargo audit` - Security vulnerability scan
- `cargo doc` - Generate documentation

### Testing

- `cargo test --lib` - Run unit tests
- `cargo test --test integration_tests` - Run integration tests
- `TERM=dumb cargo test` - Test with dumb terminal

## AI Assistant Behavior and Guidelines

- **Clarity and Precision**: Be direct, professional, and context-aware in all interactions
- **Adherence to Standards**: Strictly follow the defined rules for architecture, code style, and testing
- **Code Generation**: Generated code must conform to all established patterns
- **Tool Usage**:
  - Use `cargo` commands for Rust development
  - Use `just` for task automation
  - Use `cargo clippy -- -D warnings` for strict linting
- **Project Context**: Maintain clear focus on OPNsense configuration generation
- **Security**: Never hardcode secrets, credentials, or sensitive data
- **Testing**: Always run tests after changes and ensure they pass

## Project-Specific Notes

### OPNsense Config Faker

- Primary focus on OPNsense firewall configuration generation
- CSV is an intermediate format, XML is the primary output
- Realistic network data generation with RFC compliance
- Support for both CLI usage and programmatic integration
- Maintains compatibility with legacy Python implementation patterns

### Performance Considerations

- Memory-efficient processing for large configuration sets
- Streaming I/O for handling large datasets
- Benchmark-driven optimization with regression detection
- Cross-platform compatibility (Windows, macOS, Linux)

- Benchmark-driven optimization with regression detection
- Cross-platform compatibility (Windows, macOS, Linux)

# OPNsense Config Faker - AI Coding Assistant Rules

The primary function of this project is to generate OPNsense firewall configuration in XML format using randomly generated, but valid, data. These configurations are used to test various security tools and services that parse and validate OPNsense XML configurations.

This document outlines the coding standards, architectural patterns, and project layout preferences for the OPNsense Config Faker project. It serves as a comprehensive guide for AI coding assistants to ensure consistency, maintainability, and adherence to established best practices.

## Core Philosophy

**Framework-First Principle**: Always prefer built-in functionality from frameworks like Clap and Serde over custom or "clever" solutions. Trust the framework's serialization, validation, and CLI mechanisms.

**Operator-Centric Design**: Projects are built for operators, by operators. This means prioritizing workflows that are efficient, auditable, and functional in contested or airgapped environments.

**Single Platform Focus**: OPNsense firewall configuration generation only - not a general network configuration tool. This functionality may come in the future, but is not the primary focus of this project at this time. Plan for the future accordingly, but build for the present.

## Project Structure and Layout

The project follows a structured layout with clear separation of concerns:

```text
/
├── src/
│   ├── cli/               # Command line interface (Clap)
│   ├── generator/         # Core data generation logic
│   ├── io/               # Input/output handling (CSV, XML)
│   ├── model/            # Data models and structures
│   ├── validate/         # Validation framework
│   ├── xml/              # XML processing and generation
│   └── lib.rs            # Library entry point
├── tests/                # Integration tests
├── benches/              # Performance benchmarks
├── justfile              # Task runner configuration
└── Cargo.toml            # Project metadata and dependencies
```

## Technology Stack

The preferred technology stack is consistent across the project:

| Layer        | Technology                                    | Notes                                             |
| ------------ | -------------------------------------------- | ------------------------------------------------- |
| **Language** | Rust 2021 Edition                           | Modern Rust with idiomatic patterns.             |
| **CLI**      | Clap v4 with derive macros                  | For clean, user-friendly command-line interfaces. |
| **Serialization** | serde with CSV/XML support              | For data interchange and file I/O.               |
| **XML**      | quick-xml or roxmltree                      | For OPNsense XML configuration handling.         |
| **Testing**  | built-in test framework, criterion.rs       | For unit tests and performance benchmarking.     |
| **CI/CD**    | GitHub Actions                              | For automated testing, linting, and releases.    |
| **Tooling**  | `cargo` for deps, `just` for task running   | `cargo clippy` and `cargo fmt` for quality.      |

## Architecture Patterns

- **Command Pattern**: CLI commands encapsulated as discrete operations
- **Builder Pattern**: Used for complex configuration objects
- **Strategy Pattern**: Pluggable algorithms for different output formats
- **Error Chaining**: Comprehensive error context through the call stack
- **Resource Management**: RAII principles for file handles and system resources

## Coding Standards and Conventions

### Rust

- **Formatting**: `cargo fmt` using standard Rust formatting.
- **Linting**: `cargo clippy -- -D warnings` to enforce strict zero-warning policy.
- **Naming**: Follow standard Rust conventions - `snake_case` for variables/functions, `PascalCase` for types.
- **Error Handling**: Use `Result<T, E>` types and `?` operator. Create custom error types when needed.
- **Documentation**: Comprehensive `///` doc comments for all public APIs.
- **Testing**: Unit tests co-located with code, integration tests in `tests/` directory.

### Go-Style Organization Principles

Following idiomatic Rust standards:

- **Package Structure**: Clear module hierarchy with single responsibility
- **Naming**: Descriptive names that convey intent and scope
- **Error Handling**: Explicit error handling with context preservation
- **Testing**: Table-driven tests where applicable, comprehensive coverage
- **Documentation**: Self-documenting code with clear examples

### Commit Messages

- **Conventional Commits**: All commit messages must adhere to the [Conventional Commits](https://www.conventionalcommits.org) specification.
  - **Types**: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`
  - **Scopes**: `(cli)`, `(generator)`, `(xml)`, `(validation)`, `(io)`, etc.
  - **Breaking Changes**: Indicated with `!` in the header or `BREAKING CHANGE:` in the footer

## Quality Assurance

### Development Rules of Engagement

- **Clippy Strict**: Always enforce `cargo clippy -- -D warnings` - zero tolerance for warnings
- **OpenAPI Generator**: Use OpenAPI Generator for client code generation where applicable
- **TERM=dumb Support**: Ensure terminal output respects `TERM="dumb"` for CI environments
- **CodeRabbit.ai Preferred**: Use coderabbit.ai for code review over GitHub Copilot auto-reviews
- **Single Maintainer**: Configure workflows for single maintainer (UncleSp1d3r) without second reviewer
- **No Auto-commits**: Never commit code automatically without explicit maintainer permission

### Testing Strategy

A comprehensive testing approach:

1. **Unit Tests**: Co-located with modules using `#[cfg(test)]`
2. **Integration Tests**: End-to-end workflows in `tests/` directory
3. **Benchmarks**: Performance regression detection in `benches/` directory
4. **Property Tests**: Using `proptest` for edge case discovery
5. **CI Validation**: All tests must pass in CI with strict linting

## Common Commands and Workflows

### Development Commands

- `cargo build` - Build the project
- `cargo test` - Run all tests
- `cargo bench` - Run benchmarks
- `just qa` - Run quality assurance checks
- `just clippy` - Run strict clippy lints

### Quality Assurance

- `cargo clippy -- -D warnings` - Strict linting (zero warnings)
- `cargo fmt --check` - Check code formatting
- `cargo audit` - Security vulnerability scan
- `cargo doc` - Generate documentation

### Testing

- `cargo test --lib` - Run unit tests
- `cargo test --test integration_tests` - Run integration tests
- `TERM=dumb cargo test` - Test with dumb terminal

## AI Assistant Behavior and Guidelines

- **Clarity and Precision**: Be direct, professional, and context-aware in all interactions
- **Adherence to Standards**: Strictly follow the defined rules for architecture, code style, and testing
- **Code Generation**: Generated code must conform to all established patterns
- **Tool Usage**:
  - Use `cargo` commands for Rust development
  - Use `just` for task automation
  - Use `cargo clippy -- -D warnings` for strict linting
- **Project Context**: Maintain clear focus on OPNsense configuration generation
- **Security**: Never hardcode secrets, credentials, or sensitive data
- **Testing**: Always run tests after changes and ensure they pass

## Project-Specific Notes

### OPNsense Config Faker

- Primary focus on OPNsense firewall configuration generation
- CSV is an intermediate format, XML is the primary output
- Realistic network data generation with RFC compliance
- Support for both CLI usage and programmatic integration
- Maintains compatibility with legacy Python implementation patterns

### Performance Considerations

- Memory-efficient processing for large configuration sets
- Streaming I/O for handling large datasets
- Benchmark-driven optimization with regression detection
- Cross-platform compatibility (Windows, macOS, Linux)

- Benchmark-driven optimization with regression detection
- Cross-platform compatibility (Windows, macOS, Linux)
