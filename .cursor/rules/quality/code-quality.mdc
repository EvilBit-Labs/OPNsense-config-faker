---
globs: **/*.rs,**/Cargo.toml,**/*.md,**/justfile
alwaysApply: true
---

# Code Quality Standards for OPNsense-config-faker

## Quality Philosophy

- **Zero Warnings Policy**: All code must compile with `cargo clippy -- -D warnings`
- **Network Validity First**: Quality checks emphasize network configuration correctness
- **Automated Enforcement**: Quality gates prevent low-quality code from merging
- **Consistent Standards**: All contributors follow identical quality standards

## Rust Code Quality

### Clippy Configuration

```toml
# Cargo.toml - Workspace level clippy configuration
[workspace.lints.clippy]
# Mandatory lints - treat as errors
all = "deny"
correctness = "deny"
suspicious = "deny"
complexity = "deny"
perf = "deny"
style = "warn"
pedantic = "warn"
nursery = "warn"
cargo = "warn"

# Performance lints
inefficient_to_string = "deny"
large_enum_variant = "deny"
large_types_passed_by_value = "warn"
linkedlist = "deny"
mutex_atomic = "deny"
naive_bytecount = "deny"
or_fun_call = "deny"
slow_vector_initialization = "deny"
stable_sort_primitive = "deny"
zero_sized_map_values = "deny"

# Correctness and safety
clone_on_ref_ptr = "deny"
cmp_null = "deny"
drop_copy = "deny"
drop_ref = "deny"
forget_copy = "deny"
forget_ref = "deny"
mem_forget = "deny"
mem_replace_with_default = "deny"
unneeded_field_pattern = "deny"
unused_self = "deny"

# Allow specific lints that conflict with our style
module_name_repetitions = "allow"  # Common in network domain modeling
similar_names = "allow"            # Network interface names are often similar
too_many_arguments = "allow"       # CLI config structs can have many params
type_complexity = "allow"          # Complex types for comprehensive network APIs

[workspace.lints.rust]
missing_docs = "warn"              # Document public APIs
dead_code = "warn"                 # Clean up unused code
unused_imports = "deny"            # Remove unused imports
unused_variables = "deny"          # Clean variable usage
```

### Rustfmt Configuration

```toml
# rustfmt.toml - Consistent formatting standards
max_width = 100
hard_tabs = false
tab_spaces = 4
newline_style = "Unix"
use_small_heuristics = "Default"
indent_style = "Block"
wrap_comments = true
format_code_in_doc_comments = true
comment_width = 80
normalize_comments = true
normalize_doc_attributes = true
format_strings = false
format_macro_matchers = true
format_macro_bodies = true
empty_item_single_line = true
struct_lit_single_line = true
fn_single_line = false
where_single_line = false
imports_indent = "Block"
imports_layout = "Mixed"
imports_granularity = "Crate"
group_imports = "StdExternalCrate"
reorder_imports = true
reorder_modules = true
type_punctuation_density = "Wide"
space_before_colon = false
space_after_colon = true
spaces_around_ranges = false
binop_separator = "Front"
remove_nested_parens = true
combine_control_expr = true
overflow_delimited_expr = false
match_arm_blocks = true
fn_args_layout = "Tall"
brace_style = "SameLineWhere"
control_brace_style = "AlwaysSameLine"
trailing_semicolon = true
trailing_comma = "Vertical"
match_block_trailing_comma = false
blank_lines_upper_bound = 1
blank_lines_lower_bound = 0
edition = "2021"
version = "Two"
merge_derives = true
use_try_shorthand = false
use_field_init_shorthand = false
force_explicit_abi = true
color = "Auto"
required_version = "1.7.0"
```

### Code Organization Standards

```rust
// File organization template for network configuration modules
//! Module-level documentation
//!
//! Network configuration generation and validation for OPNsense.
//! All generated configurations are tested for validity against IEEE standards
//! and OPNsense schema requirements.

// Standard library imports first
use std::collections::HashMap;
use std::fmt::{Display, Formatter};
use std::path::PathBuf;

// External crate imports second, grouped by crate
use clap::{Args, Parser, Subcommand};
use ipnet::IpNet;
use serde::{Deserialize, Serialize};
use thiserror::Error;

// Internal imports last
use crate::generators::{VlanGenerator, NetworkRange};
use crate::models::{VlanConfig, FirewallRule};
use crate::validators::NetworkValidator;

// Constants and type aliases
const MAX_VLAN_ID: u16 = 4094;
const DEFAULT_VLAN_COUNT: u32 = 10;

type Result<T> = std::result::Result<T, ConfigGenerationError>;

// Public types first
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct NetworkConfiguration {
    pub vlans: Vec<VlanConfig>,
    pub interfaces: Vec<InterfaceConfig>,
}

// Private types second
#[derive(Debug)]
struct ConfigurationBuilder {
    vlans: Vec<VlanConfig>,
}

// Implementations
impl NetworkConfiguration {
    /// Creates a new network configuration with validation
    pub fn new() -> Self {
        Self {
            vlans: Vec::new(),
            interfaces: Vec::new(),
        }
    }
}

// Tests at the end
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_network_configuration_creation() {
        let config = NetworkConfiguration::new();
        assert!(config.vlans.is_empty());
        assert!(config.interfaces.is_empty());
    }
}
```

## Error Handling Quality

### Error Type Standards

```rust
// Comprehensive error handling for network configuration generation
use thiserror::Error;

#[derive(Debug, Error)]
pub enum ConfigGenerationError {
    /// Network configuration errors
    #[error("Invalid VLAN ID: {id}. Must be between 1 and {max}")]
    InvalidVlanId { id: u16, max: u16 },

    #[error("Network range conflict detected: {range1} conflicts with {range2}")]
    NetworkRangeConflict { range1: String, range2: String },

    #[error("Invalid interface name: '{name}'. Must follow format: {expected_format}")]
    InvalidInterfaceName { name: String, expected_format: String },

    #[error("Firewall rule validation failed: {rule_name} - {reason}")]
    InvalidFirewallRule { rule_name: String, reason: String },

    /// File and I/O errors
    #[error("Failed to write {format} output to {path}")]
    OutputWriteFailed {
        format: String,
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("XML generation failed for {config_type}")]
    XmlGenerationFailed {
        config_type: String,
        #[source]
        source: quick_xml::Error,
    },

    #[error("CSV generation failed for {config_type}")]
    CsvGenerationFailed {
        config_type: String,
        #[source]
        source: csv::Error,
    },

    /// Validation errors
    #[error("Schema validation failed: {details}")]
    SchemaValidationFailed { details: String },
}

// Helper methods for user-friendly error reporting
impl ConfigGenerationError {
    /// Get user-friendly error message with suggestions
    pub fn user_message(&self) -> String {
        match self {
            ConfigGenerationError::InvalidVlanId { id, max } => {
                format!("VLAN ID {} is invalid. Use a value between 1 and {}.", id, max)
            }
            ConfigGenerationError::NetworkRangeConflict { range1, range2 } => {
                format!(
                    "Network ranges {} and {} conflict. Adjust the configuration to use non-overlapping ranges.",
                    range1, range2
                )
            }
            _ => self.to_string(),
        }
    }

    /// Get actionable suggestions for resolving the error
    pub fn suggestions(&self) -> Vec<String> {
        match self {
            ConfigGenerationError::InvalidVlanId { .. } => vec![
                "Use --base-id to set a valid starting VLAN ID".to_string(),
                "Reduce --count to fit within the valid range".to_string(),
            ],
            ConfigGenerationError::NetworkRangeConflict { .. } => vec![
                "Use --network-base to specify a different base network".to_string(),
                "Increase subnet size to avoid conflicts".to_string(),
            ],
            _ => vec![]
        }
    }
}
```

### Result Type Patterns

```rust
// Consistent Result type usage throughout the application
pub type Result<T> = std::result::Result<T, ConfigGenerationError>;

// Function signature patterns with comprehensive error context
pub fn generate_vlan_config(
    count: u32,
    base_id: u16,
    base_network: IpNet,
) -> Result<Vec<VlanConfig>> {
    // Validate input parameters
    if base_id == 0 || base_id > MAX_VLAN_ID {
        return Err(ConfigGenerationError::InvalidVlanId { 
            id: base_id, 
            max: MAX_VLAN_ID 
        });
    }

    if base_id + count as u16 > MAX_VLAN_ID {
        return Err(ConfigGenerationError::InvalidVlanId { 
            id: base_id + count as u16,
            max: MAX_VLAN_ID
        });
    }

    // Generate configurations with proper error handling
    let vlans = (0..count)
        .map(|i| {
            let vlan_id = base_id + i as u16;
            VlanConfig::new(
                vlan_id,
                format!("VLAN_{:04}", vlan_id),
                "em0".to_string(),
                calculate_vlan_network(base_network, i)?,
            )
        })
        .collect::<Result<Vec<_>>>()?;

    Ok(vlans)
}
```

## Documentation Quality

### Documentation Standards

```rust
/// Generates realistic VLAN configurations for OPNsense testing.
///
/// This function creates VLAN configurations that comply with IEEE 802.1Q
/// standards and can be imported into OPNsense for comprehensive network
/// testing scenarios.
///
/// # Arguments
///
/// * `count` - Number of VLANs to generate (1-4094)
/// * `base_id` - Starting VLAN ID for sequential generation
/// * `base_network` - Base network range for VLAN subnets
/// * `include_descriptions` - Whether to include descriptive text
///
/// # Returns
///
/// Returns `Ok(Vec<VlanConfig>)` containing valid VLAN configurations, or an error
/// if the parameters would result in invalid VLAN IDs or network conflicts.
///
/// # Errors
///
/// This function will return an error if:
/// - `base_id` is 0 or would cause VLAN ID overflow beyond 4094
/// - `count` is 0 or would result in too many VLANs
/// - Network range calculations result in invalid subnets
/// - Generated configurations fail validation against OPNsense schema
///
/// # Network Validity
///
/// - All VLAN IDs are within IEEE 802.1Q standard range (1-4094)
/// - Generated network ranges avoid common RFC 1918 conflicts
/// - Subnet calculations ensure non-overlapping address spaces
/// - XML output validates against OPNsense configuration schema
///
/// # Examples
///
/// ```rust
/// use opnsense_config_faker::generators::generate_vlan_config;
/// use ipnet::IpNet;
///
/// let base_network: IpNet = "192.168.100.0/24".parse()?;
/// let vlans = generate_vlan_config(5, 100, base_network, true)?;
/// assert_eq!(vlans.len(), 5);
/// assert!(vlans.iter().all(|v| v.id >= 100 && v.id < 105));
/// ```
///
/// # Performance
///
/// Generation time scales linearly with count:
/// - Small datasets (<100 VLANs): ~10-50ms
/// - Medium datasets (100-1000 VLANs): 50-500ms  
/// - Large datasets (>1000 VLANs): 500ms-2s
///
/// Memory usage is approximately 1KB per VLAN configuration.
pub fn generate_vlan_config(
    count: u32,
    base_id: u16,
    base_network: IpNet,
    include_descriptions: bool,
) -> Result<Vec<VlanConfig>> {
    // Implementation...
}
```

## Testing Quality Standards

### Test Structure and Organization

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;
    use rstest::*;

    /// Test helper for creating valid test configurations
    fn create_test_vlan(id: u16) -> VlanConfig {
        VlanConfig::new(
            id,
            format!("TestVLAN{}", id),
            "em0".to_string(),
            "192.168.1.0/24".parse().unwrap(),
        ).unwrap()
    }

    /// Test basic VLAN configuration validation
    #[rstest]
    #[case(1, true)]      // Minimum valid VLAN ID
    #[case(4094, true)]   // Maximum valid VLAN ID
    #[case(0, false)]     // Invalid: 0
    #[case(4095, false)]  // Invalid: >4094
    fn test_vlan_id_validation(#[case] id: u16, #[case] should_be_valid: bool) {
        let result = VlanConfig::new(
            id,
            "Test VLAN".to_string(),
            "em0".to_string(),
            "192.168.1.0/24".parse().unwrap(),
        );

        assert_eq!(result.is_ok(), should_be_valid);
    }

    /// Test network range validation
    #[test]
    fn test_network_range_validation() {
        let vlan = create_test_vlan(100);
        assert!(vlan.network.prefix_len() >= 8);
        assert!(vlan.network.prefix_len() <= 30);
    }

    /// Property-based testing for edge cases
    proptest! {
        #[test]
        fn test_vlan_generation_properties(
            count in 1..100u32,
            base_id in 1..4000u16
        ) {
            let base_network = "192.168.0.0/24".parse().unwrap();
            let vlans = generate_vlan_config(count, base_id, base_network, false);
            
            if let Ok(vlans) = vlans {
                prop_assert_eq!(vlans.len(), count as usize);
                
                // Verify all VLAN IDs are in valid range
                for vlan in &vlans {
                    prop_assert!(vlan.id >= 1 && vlan.id <= 4094);
                    prop_assert!(!vlan.name.is_empty());
                }
                
                // Ensure no duplicate VLAN IDs
                let mut ids: Vec<_> = vlans.iter().map(|v| v.id).collect();
                ids.sort();
                ids.dedup();
                prop_assert_eq!(ids.len(), vlans.len());
            }
        }
    }
}
```

## CI/CD Quality Gates

### Quality Check Commands

```bash
#!/bin/bash
# scripts/quality-check.sh - Comprehensive quality validation

set -euo pipefail

echo "🔍 Running comprehensive quality checks..."

# 1. Formatting check
echo "📏 Checking code formatting..."
cargo fmt --all -- --check
if [ $? -ne 0 ]; then
    echo "❌ Code formatting issues found. Run 'cargo fmt' to fix."
    exit 1
fi

# 2. Clippy with zero warnings
echo "🔧 Running Clippy with strict linting..."
cargo clippy --all-features --all-targets -- -D warnings
if [ $? -ne 0 ]; then
    echo "❌ Clippy warnings found. Fix all warnings before proceeding."
    exit 1
fi

# 3. Test execution
echo "🧪 Running all tests..."
cargo test --all-features --verbose
if [ $? -ne 0 ]; then
    echo "❌ Tests failed. Fix failing tests before proceeding."
    exit 1
fi

# 4. Documentation tests
echo "📚 Running documentation tests..."
cargo test --doc --all-features
if [ $? -ne 0 ]; then
    echo "❌ Documentation tests failed."
    exit 1
fi

# 5. Coverage check
echo "📊 Checking test coverage..."
cargo llvm-cov --all-features --workspace --fail-under-lines 80
if [ $? -ne 0 ]; then
    echo "❌ Test coverage below 80% threshold."
    exit 1
fi

# 6. Benchmark performance regression check
echo "📈 Running performance benchmarks..."
cargo bench -- --output-format json > benchmark_results.json
if [ $? -ne 0 ]; then
    echo "❌ Benchmark execution failed."
    exit 1
fi

# 7. Documentation generation
echo "📖 Generating documentation..."
cargo doc --all-features --no-deps
if [ $? -ne 0 ]; then
    echo "❌ Documentation generation failed."
    exit 1
fi

echo "✅ All quality checks passed!"
```

## Quality Metrics and Monitoring

### Code Quality Metrics

- **Cyclomatic Complexity**: Maximum 15 per function (network logic can be complex)
- **Test Coverage**: Minimum 80% line coverage
- **Documentation Coverage**: 100% for public APIs
- **Clippy Warnings**: Zero warnings policy
- **Performance Regressions**: <10% performance degradation per release
- **Network Configuration Validity**: 100% of generated configs must validate

### Quality Dashboard

```toml
# Cargo.toml - Quality measurement tools
[dev-dependencies]
criterion = { version = "0.7", features = ["html_reports"] }
cargo-llvm-cov = "0.6"
rstest = "0.26"
proptest = "1.4"
assert_cmd = "2.0"
assert_fs = "1.1"

[package.metadata.coverage]
min-coverage = 80
exclude-files = ["tests/*", "benches/*", "examples/*"]

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]
```

This comprehensive quality framework ensures that OPNsense-config-faker maintains the highest standards of code quality, network configuration validity, and maintainability throughout its development lifecycle.
