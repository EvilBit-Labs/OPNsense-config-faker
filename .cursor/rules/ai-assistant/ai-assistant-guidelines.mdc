---
alwaysApply: true
---

# AI Assistant Guidelines for OPNsense-config-faker

## Development Rules of Engagement

- This project is managed in [GitHub](https://github.com/EvilBit-Labs/OPNsense-config-faker). All changes should be made via pull requests and issues should never be manually closed, only through the associated pull request.
- **TERM=dumb Support**: Ensure terminal output respects `TERM="dumb"` environment variable for CI/automation
- **CodeRabbit.ai Integration**: Prefer coderabbit.ai for code review over GitHub Copilot auto-reviews
- **Single Maintainer Workflow**: Configure for single maintainer (UncleSp1d3r) with no second reviewer requirement
- **No Auto-commits**: Never commit code on behalf of maintainer without explicit permission
- **Quality-First**: All code changes must maintain high quality standards for network configuration generation

## Assistant Behavior Rules

- **Clarity and Precision**: Be direct, professional, and context-aware in all interactions
- **Adherence to Standards**: Strictly follow the defined rules for Rust code style and project structure
- **Tool Usage**: Use `just` for task execution, `cargo` commands for Rust development
- **Focus on Value**: Enhance the project's unique value proposition as a network configuration test data generator
- **Respect Documentation**: Always consult and follow project documentation before making changes

## Code Generation Requirements

- Generated code must conform to all established Rust patterns
- Include comprehensive error handling with `Result<T, E>` and custom error types
- Follow architectural patterns (Service, Factory, Command where appropriate)
- Include appropriate `///` documentation and testing
- Use proper type safety through Rust's type system
- Maintain network configuration accuracy and validity

## AI Agent Mandatory Practices

When AI agents contribute to this project, they **MUST**:

01. **Always run tests** after making changes: `just test`
02. **Run linting** before committing: `just lint` (enforces `cargo clippy -- -D warnings`)
03. **Follow the established Rust patterns** shown in existing code
04. **Use the preferred tooling commands** (see justfile)
05. **Write comprehensive tests** for new functionality (unit, integration, property-based)
06. **Include proper error handling** with context using `thiserror`
07. **Add user-facing output** for important operations using console styling and indicatif progress indicators
08. **Validate all inputs** and handle edge cases securely
09. **Document new functions and types** following Rust `///` conventions
10. **Never hardcode configuration** - use appropriate data generation patterns
11. **Consult project documentation** - README.md, ROADMAP.md, TESTING.md for guidance
12. **Maintain network configuration validity** in all generated data
13. **Test CLI output formats** and ensure proper data validation
14. **Validate generated configurations** against OPNsense schema requirements

## Common Commands and Workflows

### Development Commands

```bash
# Primary development workflow
just dev                 # Run development checks (format, lint, test, coverage)
just install            # Install dependencies and setup environment
just build              # Complete build with optimizations

# Code quality
just format             # Format code with cargo fmt
just lint               # Run linting with strict warnings (cargo clippy -- -D warnings)
just check              # Run pre-commit hooks and comprehensive checks
just ci-check           # Run CI-equivalent checks locally

# Testing
just test               # Run the full test suite
just test-unit          # Run unit tests only
just test-integration   # Run integration tests
just test-property      # Run property-based tests with proptest
just coverage           # Run test coverage with >80% threshold
just coverage-html      # Generate HTML coverage report

# Benchmarking
just bench              # Run all benchmarks
just bench-vlan         # Benchmark VLAN generation specifically
just bench-xml          # Benchmark XML generation specifically
just bench-csv          # Benchmark CSV operations specifically

# Building and packaging
just build-release      # Build optimized release version
just package            # Create distribution package
```

### Usage Examples

```bash
# Primary use cases - Network configuration generation
cargo run -- generate vlan --count 100 --output vlans.xml
cargo run -- generate firewall-rules --complexity medium --output rules.xml
cargo run -- generate interfaces --type physical --count 24 --output interfaces.csv

# CLI testing and validation
cargo run -- --help
cargo run -- generate --help
cargo run -- validate --input test-config.xml
```

## Development Process

### Pre-Development

1. **Review Requirements**: Understand specific requirements in ROADMAP.md and TESTING.md
2. **Check Existing Code**: Review similar implementations for Rust patterns
3. **Verify Network Validity**: Ensure changes maintain valid network configurations

### Implementation

1. **Implement Changes**: Follow established Rust patterns and networking best practices
2. **Write Tests**: Create unit, integration, and property-based test coverage
3. **Update Documentation**: Update relevant documentation files

### Quality Assurance

```bash
# Format and lint
just format
just lint

# Run tests
just test

# Comprehensive validation
just ci-check
```

## Issue Resolution

When encountering problems:

- Identify the specific issue clearly
- Explain the problem in â‰¤ 5 lines
- Propose a concrete path forward that maintains network configuration validity
- Don't proceed without resolving network data accuracy issues
- Always test generated configurations for validity

## Network Configuration Guidelines

### Data Generation Standards

- Use realistic network ranges and avoid conflicts
- Ensure generated VLANs use valid ID ranges (1-4094)
- Generate MAC addresses following IEEE standards
- Use proper IP addressing schemes and subnet calculations
- Validate generated XML against OPNsense schema

### Configuration Validation

- All generated configurations must be syntactically valid
- Network ranges must be realistic and non-conflicting
- Security rules must follow logical patterns
- Interface configurations must be technically feasible

### CLI Design Principles

- Follow consistent command patterns with clap
- Provide helpful error messages with suggestions
- Include progress indicators for long operations
- Support multiple output formats (XML, CSV, JSON)
- Implement proper validation and error handling
